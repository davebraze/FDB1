##' @include is.numeral.R

##' @title Used by read.ELascii(). Not intended for end-users.
##'
##' @details
##' Used by read.ELascii(). Not intended for end-users. Extract fixations, saccades, and blinks from a trial.
##'
##' @param bounds A numeric tuple. e1 is index marking beginning of trial. e2 is index indicating
##' end of trial.
##' @param lines A vector of strings, each corresponding to 1 line of the EL ASCII file.
##' @return A list of 4 elements, data.frames enumerating fixations, saccades, blinks and TRIAL_VARs for the
##' trial.
##' @author Dave Braze \email{davebraze@@gmail.com}
getEyelinkTrialData <- function(bounds, lines) {
    fix <- grep("^EFIX", lines[bounds[1]:bounds[2]], value=TRUE)
    fix <- stringr::str_split(fix, pattern="[ \t]+")
    fix <- data.frame(matrix(unlist(fix), ncol=length(fix[[1]]), byrow=TRUE), stringsAsFactors=FALSE)
    toN <- sapply(fix, function(v) all(is.numeral(v)))
    fix <- data.frame(sapply(fix[!toN], as.factor, simplify=FALSE), sapply(fix[toN], as.numeric, simplify=FALSE))
    ## TODO Catch case where xRes and yRes are included in the output. Set names appropriately.
    names(fix) <- c('event', 'eye', 'stime', 'etime', 'dur', 'xpos', 'ypos', 'pupil')
    fix$event <- gsub("^E", "", fix$event)

    sacc <- grep("^ESACC", lines[bounds[1]:bounds[2]], value=TRUE)
    sacc <- stringr::str_split(sacc, pattern="[ \t]+")
    sacc <- data.frame(matrix(unlist(sacc), ncol=length(sacc[[1]]), byrow=TRUE), stringsAsFactors=FALSE)
    toN <- sapply(sacc, function(v) all(is.numeral(v)))
    sacc <- data.frame(sapply(sacc[!toN], as.factor, simplify=FALSE), sapply(sacc[toN], as.numeric, simplify=FALSE))
    names(sacc) <- c('event', 'eye', 'stime', 'etime', 'dur', 'xpos1', 'ypos1', 'xpos2', 'ypos2', 'ampl', 'peakvel')
    sacc$event <- gsub("^E", "", sacc$event)

    blink <- grep("^EBLINK", lines[bounds[1]:bounds[2]], value=TRUE)
    blink <- stringr::str_split(blink, pattern="[ \t]+")
    blink <- data.frame(matrix(unlist(blink), ncol=length(blink[[1]]), byrow=TRUE), stringsAsFactors=FALSE)
    toN <- sapply(blink, function(v) all(is.numeral(v)))
    blink <- data.frame(sapply(blink[!toN], as.factor, simplify=FALSE), sapply(blink[toN], as.numeric, simplify=FALSE))
    names(blink) <- c('event', 'eye', 'stime', 'etime', 'dur')
    blink$event <- gsub("^E", "", blink$event)

    trialvar <- grep("TRIAL_VAR", lines[bounds[1]:bounds[2]], value=TRUE)
    trialvar <- stringr::str_split(trialvar, pattern="[ \t]+")
    trialvar <- t(matrix(unlist(trialvar), ncol=length(trialvar[[1]]), byrow=TRUE)[,5:6])
    hdr <- trialvar[1,]
    trialvar <- data.frame(rbind(trialvar[2,]), stringsAsFactors=FALSE)
    names(trialvar) <- hdr
    toN <- sapply(trialvar, function(v) all(is.numeral(v)))
    trialvar <- data.frame(sapply(trialvar[!toN], as.factor, simplify=FALSE), sapply(trialvar[toN], as.numeric, simplify=FALSE))

    ## TODO: Get sample level data put in separate list item (data.frame).
    ## browser()
    samp <- grep("^[0-9]+", lines[bounds[1]:bounds[2]], value=TRUE)
    samp <- stringr::str_split(samp, pattern="[ \t]+")
    samp <- data.frame(matrix(unlist(samp), ncol=length(samp[[1]]), byrow=TRUE), stringsAsFactors=FALSE)
    ## NEED SOME ADDITIONAL HANDLING here to take care of '...' (when either left or right eye is
    ## not tracked) and similar composite fields
    ## Problem: fields in sample lines are different depending on
    ## o recording mode is 'remote' or 'head mounted'
    ## o eye being recorded is 'left', 'right' or 'binocular'
    ## o crossing those paramenters leads to 6 different configurations
    ## o For SAMPLE lines, there are 4 cases that need to be handled (not counting
    ##   optional velocity and resolution fields). See section 4.92 of EL1000+ user manual.
    ##   . binoc/HM recording, 8 fields (time, xposL, yposL, pupilL, xposR, yposR, pupilL, CR)
    ##   . monoc/HM recording, 5 fields (time, xpos, ypos, pupil, CR)
    ##   . binoc/remote recording, Not known at present
    ##   . monoc/remote recording, 9 fields (time, xpos, ypos, pupil, CR, xtarg, ytarg, dist, IP field)

    ## TODO: Pick up events flagged in MSG lines like the following.
    ## MSG	15334285 52 !V ARECSTART 0 1950006-letters2.wav
    ## critical information is
    ## o timestamp (15334285)
    ## o offset (52)
    ## o event type (ARECSTART)
    ## o modifier (1950006-letters2.wav)
    ##
    ## To make this work will need to pass in a list of regexp, each of which uniquely identifies
    ## each MSG of interest. If there are multiple instances of a MSG type, might need to make
    ## decisions about which to capture: first only? last only? all?
    ##
    ## Should these events be placed with trialvars, or in their own structure?

    ## TODO: For each trial from START event record
    ## o start time of eye movement recording, (timestamp from START event)
    ## o eyes recorded, LEFT, RIGHT, BINOC

    retval <- list(fix=fix, sacc=sacc, blink=blink, trialvar=trialvar)
    retval
}

##' @title Get events from SR Research ASCII data files.
##'
##' @details
##' SR Research provides a utility (EDF2ASC.exe) that dumps ASCII renderings of their proprietary
##' EDF data file format. This function reads those ASCII files and extracts eye-movement events
##' (fixations, saccades, blinks) and TRIAL_VARs from them.
##'
##' @param file A string giving path/fname to input file (ELalscii file).
##' @param tStartRE A string containing regular expression that uniquely identifies beginning of trial.
##' @param tEndRE A string containing regular expression that uniquely identifies end of trial.
##' @param eye Indicates which eye ("R"|"L") to get events from. Currently unused.
##' @return List with one element for the file header and one element for each trial. Each trial
##' element is itself a list of 4 elements: data.frames enumerating fixations, saccades, blinks and
##' TRIAL_VARs for the trial.
##' @author Dave Braze \email{davebraze@@gmail.com}
##' @export
read.ELascii <- function(file, tStartRE="TRIALID", tEndRE="TRIAL_RESULT", eye=NA) {
    f <- file(file, "r", blocking=FALSE)
    lines <- readLines(f, warn=TRUE, n=-1)
    close(f)

    ## get session information from file header
    header <- grep("^[*][*] ", lines, value=TRUE)
    script <- unlist(stringr::str_split(grep("RECORDED BY", header, value=TRUE), "[ \t]+"))[4]
    sessdate <- unlist(stringr::str_split(grep("DATE:", header, value=TRUE), ": "))[2]
    srcfile <- unlist(stringr::str_split(grep("CONVERTED FROM", header, value=TRUE), " (FROM|using) "))[2]
    srcfile <- basename(srcfile)

    ## get start and end lines for each trial block
    tStart <- grep(tStartRE, lines)
    tEnd <- grep(tEndRE, lines)
    stopifnot (length(tStart) == length(tEnd))
    trialidx <- cbind(tStart, tEnd)

    ## get trial IDs
    trialids <- unlist(stringr::str_split(grep("TRIALID", lines, value=TRUE), " TRIALID "))
    trialids <- trialids[seq(2, length(trialids), 2)]

    ## get events for each trial
    retval <- apply(trialidx, 1, getEyelinkTrialData, lines=lines)
    names(retval) <- trialids
    class(retval) <- c("ELascii", class(retval))
    retval
}


if(FALSE) {
    fname <- "../inst/extdata/1950006-RAN.asc"

#    debug(read.ELascii)
    e <- read.ELascii(fname)
#    undebug(read.ELascii)

    names(e$'2')
    head(e$'2'$fix)
    head(e$'2'$sacc)
    head(e$'2'$blink)
    dim(e$'2'$trialvar)
    names(e$'2'$trialvar)

}

##' .. content for \description{} (no empty lines) ..
##'
##' .. content for \details{} ..
##' @title Generate an ET report, as data.frame.
##' @param gaze An object of class "ELascii".
##' @param type Which type of base report to generate. Ranges over c("FIX", "SACC", "TRIALVAR").
##' @return A data.frame containing the requested report.
##' @author Dave Braze \email{davebraze@@gmail.com}
makeReport <- function(gaze, type=c("FIX", "SACC", "TRIALVAR")) {
    type <- match.arg(type)
    if (!("ELascii" %in% class(gaze))) {
        stop("Argument 'gaze' must have class 'ELascii'.")
    }

    if ("FIX" == type) {
        fixLists <- lapply (gaze, function(ll) {ll$fix})
        trials <- names(fixLists)
        for (ff in fixLists) {
            if(!exists("retval")) retval <- ff
            else retval <- rbind(retval, ff)
        }
    } else if ("SACC" == type) {
    } else if ("TRIALVAR" == type) {
    } else {
        retval <- NULL
    }
    retval
}

##' Call "edf2asc" command line utility to do some work.
##'
##' @details Call SR Research "edf2asc" command line utility to convert files.
##'
##' \enumerate{
##'     \item The best way to get the edf2asc utility is to install the Eyelink Developers Kit: https://www.sr-support.com/showthread.php?6-EyeLink-Developers-Kit-for-Windows-%28Windows-Display-Software%29.
##'     \item Documentation is in the EL1000+ manual, section 4.8 "Using ASC files".
##'     \item Make sure edfapi library (e.g., edfapi.dll) is somewhere on the PATH.
##' }
##'
##' @title Call "edf2asc" command line utility to do some work.
##' @param edffiles Vector of *edf file names.
##' @param e2afname Name of edf2asc executable (e.g., "edf2asc.exe", "edf2asc64.exe").
##' @param e2apath Path to edf2asc executable. It will probably look something like
##' "D:\winbin\SR Research\EyeLink\EDF_Access_API\Example" from "SR Research" on down.
##' @param files A character vector listing file names to be converted.
##' @return A character vector listing output files.
##' @author Dave Braze \email{davebraze@@gmail.com}
edf2asc <- function(edffiles, e2afname="edf2asc64.exe", e2apath="D:/winbin/SR Research/EyeLink/EDF_Access_API/Example") {
    ## o use R function system() to make the call, but also see shell(), shell.exec() and, possibly, system2()
    ## o see R function shQuote() for help building the command line string.
}


